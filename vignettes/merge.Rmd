---
title: "Merging HIP and PPS episodes into HIPPS"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Merging HIP and PPS into HIPPS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE
)
```

The **merge** step combines pregnancy episodes from **HIP** (outcome-anchored) and **PPS** (timing-anchored) into a single HIPPS episode table. It is run via `mergeHipps()` and writes `hipps_episodes.rds`, which is the input to the ESD step. See the [pipeline overview](algorithm.html), [HIP](hip.html), [PPS](pps.html), and [ESD](esd.html) vignettes.

## Overview

The merge step combines pregnancy episodes generated by two algorithms:

* HIP (algorithm 1): episodes with an estimated start date and an outcome-associated end date.
* PPS (algorithm 2): episodes constructed from gestational timing concepts, summarized as a start date and an end date.

The goal is a unified episode table (HIPPS) with one row per merged episode, per person, and a consistent set of downstream columns.

The merge has three stages:

1. Standardize HIP and PPS episode representations and identifiers.
2. Merge by temporal overlap within person.
3. Resolve many-to-many overlaps by selecting a best match (deduplication), then compute final merged dates and flags.

## Inputs

`mergeHipps()` reads from `outputDir`:

* **hip_episodes.rds** — HIP episodes (from `runHip()`): `person_id`, `episode`, `estimated_start_date`, `visit_date`, `gest_date`, `category`, etc.
* **pps_episodes.rds** — PPS episodes with inferred outcomes (from `runPps()`): `person_id`, `person_episode_number`, `episode_min_date`, `episode_max_date`, `episode_max_date_plus_two_months`, outcome columns, etc.

## Standardized episode intervals

HIP episodes are standardized to the interval:

* `pregnancy_start` = `estimated_start_date`
* `pregnancy_end`   = `visit_date` (the date used as HIP episode end)
* `first_gest_date` = `gest_date` (first gestation date in the episode)

PPS episodes use:

* `episode_min_date` = start of PPS episode evidence
* `episode_max_date_plus_two_months` = PPS episode end extended by two months

The PPS extension allows for delayed capture of outcome-related records relative to the final gestational timing concept.

Each episode is given a stable within-person identifier:

* `algo1_id` = `{person_id}_{episode}_1` for HIP
* `algo2_id` = `{person_id}_{person_episode_number}_2` for PPS

## Merge criterion: overlap within person

HIP and PPS episodes are merged if their intervals overlap. The overlap predicate implemented in `mergeEpisodes()` is:

* `pregnancy_start <= episode_max_date_plus_two_months` and
* `pregnancy_end   >= episode_min_date`

This is the standard interval overlap test (including containment and partial overlap). Conceptually:

```
HIP:  [pregnancy_start ---------------- pregnancy_end]
PPS:              [episode_min_date -------- episode_max_date_plus_two_months]
                 overlap if the ranges intersect
```

Episodes that do not overlap remain in the merged table as one-sided episodes (HIP-only or PPS-only) through the `full_join()`.

## Construction of merged episode dates

For each overlapping HIP–PPS pair (and for one-sided episodes where one algorithm is missing), the merged episode start and end are computed as:

* `merged_episode_start` = min(`first_gest_date`, `episode_min_date`, `pregnancy_end`)
* `merged_episode_end`   = max(`episode_max_date`, `pregnancy_end`)

and `merged_episode_length` is computed as the time between these dates (in months).

This produces a conservative interval that spans evidence from both algorithms.

## Many-to-many overlaps and why deduplication is needed

A single HIP episode can overlap multiple PPS episodes, and vice versa. This creates many-to-many matches after the overlap join.

Example (one HIP episode overlapping two PPS episodes):

```
HIP:  [--------------------]
PPS1:    [-----------]
PPS2:               [-----------]
```

The merge generates two candidate rows for the same HIP episode. Without additional rules, downstream analyses would double-count episodes.

The function flags candidate duplicates:

* `algo1_dup = 1` when a HIP id (`algo1_id`) appears in more than one merged row.
* `algo2_dup = 1` when a PPS id (`algo2_id`) appears in more than one merged row.

## Deduplication strategy: select best-matching pairs

`dedupeMergedEpisodes()` resolves many-to-many overlaps by selecting best matches and removing the remaining duplicate overlap rows.

The strategy preserves:

* rows that are already one-to-one matches (or one-sided episodes), and
* one best overlap match per duplicated HIP episode and per duplicated PPS episode.

### Scoring candidate matches

For a candidate HIP–PPS overlap row, the primary score is the absolute difference in end dates:

* `date_diff = | HIP_end - PPS_end |`

Smaller values indicate the two algorithms are identifying the same pregnancy episode end.

For HIP-based selection, candidates are additionally penalized when the PPS episode has no inferred outcome category:

* if `algo2_category` is missing, `date_diff` is set to a large value (effectively deprioritizing that match).

Episode plausibility is also considered using PPS episode duration:

* `pps_days` = |`episode_max_date` − `episode_min_date`| (PPS episode length in days)
* PPS candidates with duration > 310 days are treated as implausible and deprioritized in tie-breaking.

### Selection rule

For each duplicated episode identifier (HIP or PPS), the algorithm:

1. selects the row(s) with minimal `date_diff`, and then
2. breaks ties using `pps_days` (favoring plausible PPS episodes with reasonable duration).

This selection is applied in rounds. After each round, duplication flags are recomputed because selecting one best match can eliminate duplicates downstream.

The net effect is to retain a consistent set of one-to-one merged rows while keeping unpaired HIP-only and PPS-only episodes.

## Output: standardized merged episode table

After deduplication, `addMergedEpisodeDetails()` standardizes columns and adds outcome/date fields (e.g. `algo2_category` set to `PREG` when PPS has no inferred outcome; `algo2_outcome_date` set from `episode_max_date` when missing). Episodes are ordered within person and assigned `episode_number` based on `recorded_episode_start` (and related merged dates).

The final artifact written to disk is:

* **hipps_episodes.rds**

This file contains one row per merged episode per person and is the input to `runEsd()` for episode start date refinement. See the [ESD vignette](esd.html) and the [pipeline overview](algorithm.html).
