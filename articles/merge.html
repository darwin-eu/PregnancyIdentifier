<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Merging HIP and PPS episodes into HIPPS • PregnancyIdentifier</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Merging HIP and PPS episodes into HIPPS">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">PregnancyIdentifier</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">3.0.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item"><a class="nav-link" href="../articles/index.html">Articles</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Merging HIP and PPS episodes into HIPPS</h1>
            
      

      <div class="d-none name"><code>merge.Rmd</code></div>
    </div>

    
    
<p>The <strong>merge</strong> step combines pregnancy episodes from
<strong>HIP</strong> (outcome-anchored) and <strong>PPS</strong>
(timing-anchored) into a single HIPPS episode table. It is run via
<code><a href="../reference/mergeHipps.html">mergeHipps()</a></code> and writes <code>hipps_episodes.rds</code>,
which is the input to the ESD step. See the <a href="algorithm.html">pipeline overview</a>, <a href="hip.html">HIP</a>,
<a href="pps.html">PPS</a>, and <a href="esd.html">ESD</a>
vignettes.</p>
<div class="section level2">
<h2 id="what-the-merge-does">What the merge does<a class="anchor" aria-label="anchor" href="#what-the-merge-does"></a>
</h2>
<p>The merge takes two episode tables—one from HIP and one from PPS—and
produces one table with <strong>one row per pregnancy episode per
person</strong>. For each person:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Overlap join</strong>: HIP and PPS episodes are matched
within person by <strong>temporal overlap</strong> of their intervals.
Episodes that overlap become candidate merged rows; episodes that do not
overlap any other are kept as one-sided rows (HIP-only or
PPS-only).</li>
<li>
<strong>Many-to-many</strong>: One HIP episode can overlap several
PPS episodes, and one PPS episode can overlap several HIP episodes. To
resolve this, the merge <strong>deduplicates</strong> overlapping
episodes by selecting a single best HIP–PPS pair for each episode
identifier. An episode identifier is defined as a unique combination of
person and algorithm source: for HIP episodes, the identifier is
<code>hip_episode_id = {person_id}_{hip_episode}_hip</code>, and for PPS
episodes, it is
<code>pps_episode_id = {person_id}_{pps_episode_number}_pps</code>. The
merged table keeps one matched pair for each unique combination of these
identifiers, ensuring each episode is represented only once in the
output.</li>
<li>
<strong>Final table</strong>: Merged dates and outcome fields are
standardized, and episodes are ordered within person. The result is
written to <code>hipps_episodes.rds</code>.</li>
</ol>
<p>No rows are dropped except duplicate overlap candidates; one-sided
episodes and one-to-one matches are preserved.</p>
<p><strong>Point of the merge.</strong> The merge serves three purposes
for the rest of the pipeline:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Define which episodes exist</strong> — One row per episode
after overlap and deduplication. The set of episodes (and their
identity) is fixed here.</li>
<li>
<strong>Put HIP and PPS on the same row</strong> — Each row carries
both <strong>hip_end_date</strong> /
<strong>hip_outcome_category</strong> and <strong>pps_end_date</strong>
/ <strong>pps_outcome_category</strong> (when present). The next step,
ESD, does <strong>not</strong> do another overlap-merge of HIP and PPS;
it takes this single row and <strong>picks one</strong> end date and one
outcome from the two values already on the row using harmonization
rules.</li>
<li>
<strong>Supply the evidence window</strong> —
<strong>merge_episode_start</strong> and
<strong>merge_episode_end</strong> define the interval ESD uses to pull
gestational timing concepts (GW/GR3m) from the CDM for inferring
pregnancy start. The <strong>final</strong> episode end date and outcome
in the pipeline are <strong>not</strong> taken from this merged
interval—they are chosen by ESD from <strong>hip_end_date</strong> and
<strong>pps_end_date</strong> (and the two outcomes). See the <a href="esd.html">ESD vignette</a> for how ESD chooses final start, end,
and outcome.</li>
</ol>
<hr>
</div>
<div class="section level2">
<h2 id="inputs">Inputs<a class="anchor" aria-label="anchor" href="#inputs"></a>
</h2>
<p><code>mergeHipps(outputDir, logger)</code> reads from
<code>outputDir</code>:</p>
<table class="table">
<colgroup>
<col width="20%">
<col width="26%">
<col width="53%">
</colgroup>
<thead><tr class="header">
<th>File</th>
<th>Source</th>
<th>Main columns</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><strong>hip_episodes.rds</strong></td>
<td><code><a href="../reference/runHip.html">runHip()</a></code></td>
<td>
<code>person_id</code>, <code>hip_episode</code>,
<code>hip_pregnancy_start</code>, <code>hip_pregnancy_end</code>,
<code>hip_first_gest_date</code>, <code>hip_outcome_category</code>,
etc.</td>
</tr>
<tr class="even">
<td><strong>pps_episodes.rds</strong></td>
<td><code><a href="../reference/runPps.html">runPps()</a></code></td>
<td>
<code>person_id</code>, <code>pps_episode_number</code>,
<code>pps_episode_min_date</code>, <code>pps_episode_max_date</code>,
<code>pps_episode_max_date_plus_two_months</code>, outcome columns,
etc.</td>
</tr>
</tbody>
</table>
<hr>
</div>
<div class="section level2">
<h2 id="stage-1-standardized-episode-intervals-and-ids">Stage 1: Standardized episode intervals and IDs<a class="anchor" aria-label="anchor" href="#stage-1-standardized-episode-intervals-and-ids"></a>
</h2>
<p>HIP and PPS use different date columns. The merge standardizes them
to common interval names and adds stable identifiers.</p>
<p><strong>HIP (algorithm 1)</strong><br>
- <code>pregnancy_start</code> = <code>hip_pregnancy_start</code>
(internal); output has <code>hip_episode</code>,
<code>hip_outcome_category</code>, etc.<br>
- <code>pregnancy_end</code> = <code>hip_pregnancy_end</code> (HIP
episode end)<br>
- <code>first_gest_date</code> = <code>hip_first_gest_date</code> (first
gestation date in the episode)<br>
- <code>hip_episode_id</code> =
<code>{person_id}_{hip_episode}_hip</code></p>
<p><strong>PPS (algorithm 2)</strong><br>
- <code>pps_episode_min_date</code> = start of PPS episode
evidence<br>
- <code>pps_episode_max_date_plus_two_months</code> = PPS episode end
extended by two months (allows delayed outcome capture)<br>
- <code>pps_episode_id</code> =
<code>{person_id}_{pps_episode_number}_pps</code></p>
<p>Overlap is computed on:</p>
<ul>
<li>HIP: <code>[pregnancy_start, pregnancy_end]</code>
</li>
<li>PPS:
<code>[pps_episode_min_date, pps_episode_max_date_plus_two_months]</code>
</li>
</ul>
<hr>
</div>
<div class="section level2">
<h2 id="stage-2-merge-by-overlap-full-join">Stage 2: Merge by overlap (full join)<a class="anchor" aria-label="anchor" href="#stage-2-merge-by-overlap-full-join"></a>
</h2>
<p>Episodes are merged <strong>within person</strong> using a
<strong>full join</strong> on overlap:</p>
<ul>
<li>
<strong>Overlap condition</strong>:<br><code>pregnancy_start &lt;= pps_episode_max_date_plus_two_months</code>
<strong>and</strong><br><code>pregnancy_end &gt;= pps_episode_min_date</code>
</li>
</ul>
<p>So two episodes match if their intervals intersect (including
containment).</p>
<pre><code>HIP:  [pregnancy_start ---------------- pregnancy_end]
PPS:              [pps_episode_min_date -------- pps_episode_max_date_plus_two_months]
                  &lt;-------- overlap -------&gt;</code></pre>
<ul>
<li>Rows that match: one merged row per (HIP episode, PPS episode)
pair.</li>
<li>Rows that do not match: HIP-only or PPS-only rows (one side is NA)
are kept via the full join.</li>
</ul>
<p>For each row (matched or one-sided), the merge computes:</p>
<ul>
<li>
<code>merged_episode_start</code> =
min(<code>first_gest_date</code>, <code>pps_episode_min_date</code>,
<code>pregnancy_start</code>)<br>
</li>
<li>
<code>merged_episode_end</code> =
max(<code>pps_episode_max_date</code>, <code>pregnancy_end</code>)<br>
</li>
<li>
<code>merged_episode_length</code> =
(<code>merged_episode_end</code> − <code>merged_episode_start</code>) in
months (days / 30.25)</li>
</ul>
<p><strong>Duplicate flags</strong> (used in Stage 3):</p>
<ul>
<li>
<code>duplicated_hip_episode_id</code> = 1 if that
<code>hip_episode_id</code> appears in more than one row (HIP episode
matched to multiple PPS).</li>
<li>
<code>duplicated_pps_episode_id</code> = 1 if that
<code>pps_episode_id</code> appears in more than one row (PPS episode
matched to multiple HIP).</li>
</ul>
<hr>
</div>
<div class="section level2">
<h2 id="stage-3-deduplication-loop">Stage 3: Deduplication loop<a class="anchor" aria-label="anchor" href="#stage-3-deduplication-loop"></a>
</h2>
<p>When many HIP and PPS episodes overlap, the overlap join can produce
<strong>many-to-many</strong> matches: one HIP episode paired with
several PPS episodes, and/or one PPS episode paired with several HIP
episodes. The deduplication step keeps <strong>one best match per HIP
episode and per PPS episode</strong> (and keeps one-to-one and one-sided
rows unchanged).</p>
<div class="section level3">
<h3 id="split-non-duplicates-vs-duplicates">Split: non-duplicates vs duplicates<a class="anchor" aria-label="anchor" href="#split-non-duplicates-vs-duplicates"></a>
</h3>
<ul>
<li><p><strong>baseKeep</strong>: Rows where <strong>neither</strong>
episode is duplicated:<br><code>(duplicated_hip_episode_id == 0 &amp; duplicated_pps_episode_id == 0)</code>
or one-sided (one of the dup flags is NA).<br>
These are left unchanged (one-to-one matches and HIP-only or PPS-only
episodes).</p></li>
<li><p><strong>dupDf</strong>: Rows where <strong>at least one</strong>
side is duplicated <strong>and</strong> the row is an overlap (both HIP
and PPS present):<br><code>(duplicated_hip_episode_id == 1 &amp; pps_episode_id present)</code>
or
<code>(duplicated_pps_episode_id == 1 &amp; hip_episode_id present)</code>.<br>
Only these rows go through the “pick best” logic.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="scoring-overlap-rows">Scoring overlap rows<a class="anchor" aria-label="anchor" href="#scoring-overlap-rows"></a>
</h3>
<p>For each candidate row in <code>dupDf</code>, the algorithm
computes:</p>
<ol style="list-style-type: decimal">
<li><p><strong>date_diff</strong> = |<code>pregnancy_end</code> −
<code>pps_episode_max_date</code>| (days).<br>
Smaller values mean HIP and PPS agree on episode end; the best match
minimizes this.</p></li>
<li><p><strong>Missing PPS outcome (when choosing by HIP)</strong><br>
When selecting the best PPS match for a duplicated HIP episode, rows
where <code>pps_outcome_category</code> is missing are penalized:
<code>date_diff</code> is set to a large value (10000) so they are
chosen only if no other match exists.</p></li>
<li><p><strong>pps_days</strong> = |<code>pps_episode_max_date</code> −
<code>pps_episode_min_date</code>| (PPS episode length in days).<br>
Used for tie-breaking: PPS episodes longer than 310 days are treated as
implausible and get <code>pps_days = -1</code>, so they lose ties. Among
plausible episodes, <strong>longer</strong> PPS duration is preferred
(larger <code>pps_days</code> wins).</p></li>
</ol>
</div>
<div class="section level3">
<h3 id="selection-rule-pick-best">Selection rule (“pick best”)<a class="anchor" aria-label="anchor" href="#selection-rule-pick-best"></a>
</h3>
<p>For a set of rows that share the same duplicated identifier
(e.g. same <code>hip_episode_id</code>):</p>
<ol style="list-style-type: decimal">
<li>Keep rows with <strong>smallest</strong>
<code>date_diff</code>.</li>
<li>Among ties, keep rows with <strong>largest</strong>
<code>pps_days</code> (so plausible, longer PPS episodes win).</li>
</ol>
<p>This is implemented as: <code>slice_min(date_diff, n = 1)</code> then
<code>slice_max(pps_days, n = 1)</code>. The first round uses
<code>with_ties = TRUE</code> (keep all ties); later rounds use
<code>with_ties = FALSE</code> for a deterministic single winner.</p>
</div>
<div class="section level3">
<h3 id="iterative-loop-why-multiple-rounds">Iterative loop (why multiple rounds?)<a class="anchor" aria-label="anchor" href="#iterative-loop-why-multiple-rounds"></a>
</h3>
<p>After picking the best match <strong>by HIP</strong>
(<code>hip_episode_id</code>), some <code>pps_episode_id</code> values
can still appear in more than one row. After picking the best <strong>by
PPS</strong> (<code>pps_episode_id</code>), some
<code>hip_episode_id</code> values can again appear more than once. So
one round is not enough.</p>
<p>The algorithm:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Initial pass</strong>: From <code>dupDf</code>, pick best by
<code>hip_episode_id</code> (with missing-outcome penalty) and best by
<code>pps_episode_id</code> (no penalty), combine them, then
<strong>recompute</strong> <code>duplicated_hip_episode_id</code> and
<code>duplicated_pps_episode_id</code> on this set.</li>
<li>
<strong>Up to 4 rounds</strong>: Again pick best by
<code>hip_episode_id</code> among rows still with
<code>duplicated_hip_episode_id == 1</code>, and best by
<code>pps_episode_id</code> among rows still with
<code>duplicated_pps_episode_id == 1</code>; recombine and
<strong>recompute</strong> dup flags. After each round, the rows that
are <strong>no longer</strong> duplicated (dup flags 0 or NA) are
retained for the final table.</li>
<li>
<strong>Final set</strong>: <code>baseKeep</code> (unchanged) plus
all rows that are non-duplicated after the last round, then
<code><a href="https://dplyr.tidyverse.org/reference/distinct.html" class="external-link">distinct()</a></code>.</li>
</ol>
<p>So the loop repeatedly reduces duplicate HIP and PPS ids until no
overlap row is duplicated on either side, then merges those resolved
rows with the non-duplicate rows.</p>
</div>
<div class="section level3">
<h3 id="deduplication-example">Deduplication example<a class="anchor" aria-label="anchor" href="#deduplication-example"></a>
</h3>
<p><strong>Setup</strong>: One HIP episode overlaps two PPS
episodes.</p>
<pre><code>Person 100, HIP episode 1:  [2020-01-01 -------- 2020-09-15]  (pregnancy_end = 2020-09-15)
Person 100, PPS episode 1:     [2020-02-01 --- 2020-09-10]   (pps_episode_max_date = 2020-09-10)
Person 100, PPS episode 2:              [2020-04-01 --- 2020-09-20]</code></pre>
<p>After the overlap join there are 2 rows (HIP 1–PPS 1 and HIP 1–PPS
2). Both have <code>duplicated_hip_episode_id == 1</code> (same HIP in
two rows).</p>
<p><strong>Scoring</strong>:</p>
<table style="width:100%;" class="table">
<colgroup>
<col width="10%">
<col width="22%">
<col width="25%">
<col width="15%">
<col width="25%">
</colgroup>
<thead><tr class="header">
<th>Row</th>
<th>pregnancy_end</th>
<th>pps_episode_max_date</th>
<th>date_diff</th>
<th>pps_days (e.g.)</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>HIP1–PPS1</td>
<td>2020-09-15</td>
<td>2020-09-10</td>
<td>5</td>
<td>222</td>
</tr>
<tr class="even">
<td>HIP1–PPS2</td>
<td>2020-09-15</td>
<td>2020-09-20</td>
<td>5</td>
<td>172</td>
</tr>
</tbody>
</table>
<p><strong>Pick best by hip_episode_id</strong>: Same
<code>date_diff</code>; tie-break by <code>pps_days</code>. Row
HIP1–PPS1 wins (222 &gt; 172). So the merged table keeps
<strong>one</strong> row for HIP episode 1: the pair (HIP1, PPS1).</p>
<p><strong>Another case</strong>: One PPS episode overlaps two HIP
episodes.</p>
<pre><code>Person 200, HIP episode 1: [2020-03-01 -- 2020-10-01]
Person 200, HIP episode 2:        [2020-05-01 -- 2020-11-15]
Person 200, PPS episode 1:    [2020-04-01 -------- 2020-10-20]</code></pre>
<p>PPS 1 overlaps both HIP 1 and HIP 2. We have 2 rows; both have
<code>duplicated_pps_episode_id == 1</code>. We pick the row with
smaller |<code>pregnancy_end</code> − <code>pps_episode_max_date</code>|
(and then by <code>pps_days</code> if tied). That chooses the single
best HIP for this PPS episode.</p>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="post-deduplication-standardized-columns">Post-deduplication: standardized columns<a class="anchor" aria-label="anchor" href="#post-deduplication-standardized-columns"></a>
</h2>
<p>After deduplication, <code>addMergedEpisodeDetails()</code>:</p>
<ul>
<li>Fills PPS outcome when missing: if a row has
<code>pps_episode_id</code> but <code>pps_outcome_category</code> is NA,
set <code>pps_outcome_category = "PREG"</code> and set
<code>pps_outcome_date = pps_episode_max_date</code>.</li>
<li>Renames to the final names used in the output:
<code>pregnancy_end</code> → <code>hip_end_date</code>,
<code>pps_outcome_date</code> → <code>pps_end_date</code>,
<code>merged_episode_start</code> → <code>merge_episode_start</code>,
<code>merged_episode_end</code> → <code>merge_episode_end</code>,
<code>merged_episode_length</code> → <code>merge_episode_length</code>,
<code>pregnancy_start</code> → <code>merge_pregnancy_start</code>,
<code>first_gest_date</code> → <code>merge_first_gest_date</code>. HIP
supplies <code>hip_outcome_category</code>; PPS outcome column remains
<code>pps_outcome_category</code>.</li>
<li>Adds <strong>hip_flag</strong> (1 if the row has a HIP episode, 0
otherwise) and <strong>pps_flag</strong> (1 if it has a PPS episode, 0
otherwise).</li>
<li>Recomputes merged episode dates from the retained rows, then orders
episodes within person by <code>merge_episode_start</code> and assigns
<strong>merge_episode_number</strong> (1, 2, 3, … per person).</li>
</ul>
<hr>
</div>
<div class="section level2">
<h2 id="output-file-hipps_episodes-rds">Output file: hipps_episodes.rds<a class="anchor" aria-label="anchor" href="#output-file-hipps_episodes-rds"></a>
</h2>
<p><code><a href="../reference/mergeHipps.html">mergeHipps()</a></code> writes a single file to
<code>outputDir</code>:</p>
<table class="table">
<colgroup>
<col width="31%">
<col width="68%">
</colgroup>
<thead><tr class="header">
<th>File</th>
<th>Description</th>
</tr></thead>
<tbody><tr class="odd">
<td><strong>hipps_episodes.rds</strong></td>
<td>One row per merged pregnancy episode per person; input to
<code><a href="../reference/runEsd.html">runEsd()</a></code>.</td>
</tr></tbody>
</table>
<p>If there are no episodes, the same path is written with an empty
tibble that has the correct column schema (see
<code>emptyHippsEpisodes()</code>).</p>
<div class="section level3">
<h3 id="output-columns">Output columns<a class="anchor" aria-label="anchor" href="#output-columns"></a>
</h3>
<p>The saved data frame includes the following. Columns listed as
“always present” are in every run; “present when applicable” may be NA
or omitted depending on whether the row came from HIP, PPS, or both.</p>
<p><strong>Identifiers and ordering</strong></p>
<table class="table">
<colgroup>
<col width="29%">
<col width="22%">
<col width="48%">
</colgroup>
<thead><tr class="header">
<th>Column</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>person_id</code></td>
<td>integer</td>
<td>Person identifier.</td>
</tr>
<tr class="even">
<td><code>merge_episode_number</code></td>
<td>integer</td>
<td>Within-person episode index (1, 2, 3, …) by
<code>merge_episode_start</code>.</td>
</tr>
</tbody>
</table>
<p><strong>Merged episode interval (always present)</strong></p>
<table class="table">
<colgroup>
<col width="29%">
<col width="22%">
<col width="48%">
</colgroup>
<thead><tr class="header">
<th>Column</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>merge_episode_start</code></td>
<td>Date</td>
<td>Start of the merged episode: min of
<code>merge_first_gest_date</code>, <code>pps_episode_min_date</code>,
<code>merge_pregnancy_start</code>.</td>
</tr>
<tr class="even">
<td><code>merge_episode_end</code></td>
<td>Date</td>
<td>End of the merged episode: max of <code>pps_episode_max_date</code>,
<code>hip_end_date</code>.</td>
</tr>
<tr class="odd">
<td><code>merge_episode_length</code></td>
<td>numeric</td>
<td>Length in months (days / 30.25).</td>
</tr>
</tbody>
</table>
<p><strong>Algorithm-specific end dates (always present)</strong></p>
<table class="table">
<colgroup>
<col width="29%">
<col width="22%">
<col width="48%">
</colgroup>
<thead><tr class="header">
<th>Column</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>hip_end_date</code></td>
<td>Date</td>
<td>HIP episode end (<code>hip_pregnancy_end</code>). NA if row is
PPS-only.</td>
</tr>
<tr class="even">
<td><code>pps_end_date</code></td>
<td>Date</td>
<td>PPS outcome/end date (inferred or
<code>pps_episode_max_date</code>). NA if row is HIP-only.</td>
</tr>
</tbody>
</table>
<p><strong>Outcome categories (always present)</strong></p>
<table class="table">
<colgroup>
<col width="29%">
<col width="22%">
<col width="48%">
</colgroup>
<thead><tr class="header">
<th>Column</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>hip_outcome_category</code></td>
<td>character</td>
<td>Outcome category from HIP (e.g. LB, SB, PREG). NA if PPS-only.</td>
</tr>
<tr class="even">
<td><code>pps_outcome_category</code></td>
<td>character</td>
<td>Outcome category from PPS; set to <code>"PREG"</code> when PPS has
no inferred outcome. NA if HIP-only.</td>
</tr>
</tbody>
</table>
<p><strong>Algorithm presence flags (always present)</strong></p>
<table class="table">
<thead><tr class="header">
<th>Column</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>hip_flag</code></td>
<td>integer</td>
<td>1 if this row has a HIP episode, 0 otherwise.</td>
</tr>
<tr class="even">
<td><code>pps_flag</code></td>
<td>integer</td>
<td>1 if this row has a PPS episode, 0 otherwise.</td>
</tr>
</tbody>
</table>
<p><strong>Optional / when applicable</strong></p>
<p>These columns may be included when present in the merged data
(e.g. for ESD or debugging). They can be NA for one-sided episodes.</p>
<table class="table">
<colgroup>
<col width="29%">
<col width="22%">
<col width="48%">
</colgroup>
<thead><tr class="header">
<th>Column</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>merge_pregnancy_start</code></td>
<td>Date</td>
<td>HIP <code>hip_pregnancy_start</code> (standardized name).</td>
</tr>
<tr class="even">
<td><code>merge_first_gest_date</code></td>
<td>Date</td>
<td>First gestation date in the HIP episode (from
<code>hip_first_gest_date</code>).</td>
</tr>
<tr class="odd">
<td><code>pps_episode_min_date</code></td>
<td>Date</td>
<td>PPS episode start.</td>
</tr>
<tr class="even">
<td><code>pps_episode_max_date</code></td>
<td>Date</td>
<td>PPS episode end (before 2-month extension).</td>
</tr>
<tr class="odd">
<td><code>pps_episode_max_date_plus_two_months</code></td>
<td>Date</td>
<td>PPS end + 2 months (used for overlap).</td>
</tr>
<tr class="even">
<td><code>hip_episode</code></td>
<td>integer</td>
<td>HIP episode index.</td>
</tr>
<tr class="odd">
<td><code>pps_episode_number</code></td>
<td>integer</td>
<td>PPS episode index.</td>
</tr>
<tr class="even">
<td><code>hip_episode_id</code></td>
<td>character</td>
<td>HIP episode id: <code>{person_id}_{hip_episode}_hip</code>.</td>
</tr>
<tr class="odd">
<td><code>pps_episode_id</code></td>
<td>character</td>
<td>PPS episode id:
<code>{person_id}_{pps_episode_number}_pps</code>.</td>
</tr>
</tbody>
</table>
<p>Downstream, <code><a href="../reference/runEsd.html">runEsd()</a></code> expects at least:
<code>person_id</code>, <code>merge_episode_number</code>,
<code>merge_pregnancy_start</code>, <code>merge_episode_start</code>,
<code>merge_episode_end</code>. See the <a href="esd.html">ESD
vignette</a> and the <a href="algorithm.html">pipeline overview</a>.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Aniek Markus, Julieta Politi, Maarten van Kessel, Adam Black.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
